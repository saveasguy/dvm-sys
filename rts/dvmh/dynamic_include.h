static const std::string dvmhlib_f2c = 
"\n"
"__device__ __inline__ float pow(float x, char n)                   { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, short n)                  { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, long long int n)          { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, double n)                 { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, unsigned char n)          { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, unsigned short n)         { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, unsigned int n)           { return powf(x, (float)n); }\n"
"__device__ __inline__ float pow(float x, unsigned long long int n) { return powf(x, (float)n); }\n"
"\n"
"__device__ __inline__ double pow(double x, char n)                   { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, short n)                  { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, float n)                  { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, long long int n)          { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, unsigned char n)          { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, unsigned short n)         { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, unsigned int n)           { return pow(x, (double)n); }\n"
"__device__ __inline__ double pow(double x, unsigned long long int n) { return pow(x, (double)n); }\n"
"\n"
"__device__ __inline__ float pow(char x, float n)                   { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(short x, float n)                  { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(int x, float n)                    { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(long long int x, float n)          { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(unsigned char x, float n)          { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(unsigned short x, float n)         { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(unsigned int x, float n)           { return powf((float)x, n); }\n"
"__device__ __inline__ float pow(unsigned long long int x, float n) { return powf((float)x, n); }\n"
"\n"
"__device__ __inline__ double pow(char x, double n)                   { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(short x, double n)                  { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(int x, double n)                    { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(long long int x, double n)          { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(unsigned char x, double n)          { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(unsigned short x, double n)         { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(unsigned int x, double n)           { return pow((double)x, n); }\n"
"__device__ __inline__ double pow(unsigned long long int x, double n) { return pow((double)x, n); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ int pow(int x, T n) {\n"
"    int p;\n"
"    if (x == 2)\n"
"        p = 1 << n;\n"
"    else {\n"
"        // XXX: What if both x and n are negative?\n"
"        if (n < 0)\n"
"            p = 0;// (int)powf(x, n);\n"
"        else if (n == 1)\n"
"            p = x;\n"
"        else {\n"
"            p = 1;\n"
"            int a = x;\n"
"            while (n > 0) {\n"
"                if ((n & 1) != 0)\n"
"                    p *= a;\n"
"                a *= a;\n"
"                n >>= 1;\n"
"            }\n"
"        }\n"
"    }\n"
"    return p;\n"
"}\n"
"\n"
"// for windows with type long int\n"
"__device__ __inline__ long pow(long x, int n) {\n"
"    int p;\n"
"    if (x == 2)\n"
"        p = 1 << n;\n"
"    else {\n"
"        // XXX: What if both x and n are negative?\n"
"        if (n < 0)\n"
"            p = 0;// (int)powf(x, n);\n"
"        else if (n == 1)\n"
"            p = x;\n"
"        else {\n"
"            p = 1;\n"
"            int a = x;\n"
"            while (n > 0) {\n"
"                if ((n & 1) != 0)\n"
"                    p *= a;\n"
"                a *= a;\n"
"                n >>= 1;\n"
"            }\n"
"        }\n"
"    }\n"
"    return p;\n"
"}\n"
"\n"
"__device__ __inline__ long long pow(long long x, int n) {\n"
"    long long p;\n"
"    if (x == 2)\n"
"        p = 1 << n;\n"
"    else {\n"
"        // XXX: What if both x and n are negative?\n"
"        if (n < 0)\n"
"            p = 0;// (int)powf(x, n);\n"
"        else if (n == 1)\n"
"            p = x;\n"
"        else {\n"
"            p = 1;\n"
"            long long a = x;\n"
"            while (n > 0) {\n"
"                if ((n & 1) != 0)\n"
"                    p *= a;\n"
"                a *= a;\n"
"                n >>= 1;\n"
"            }\n"
"        }\n"
"    }\n"
"    return p;\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T shiftBits(T x, int pos) {\n"
"    T val = (sizeof(x) << 3) - 1;\n"
"    if (val > 31) val = 31;\n"
"    if (pos >= 0) {\n"
"        // XXX: C standard says that left-shift of signed integers involve undefined behavior unless it is non-negative and x*2^pos is representable\n"
"        //      Undefined behavior situations are more dangerous than implementation-defined ones.\n"
"        //      Fortran 95 standard says that if the absolute value of pos is greater than bit_size(x), the value is undefined.\n"
"        while (pos > val) {\n"
"            x <<= val;\n"
"            pos -= val;\n"
"        }\n"
"        return x << pos;\n"
"    } else {\n"
"        pos = -pos;\n"
"        // XXX: C standard leaves the right-shift of signed integers implementation-defined but Intel Fortran says precisely about the arithmetic shift\n"
"        //      Fortran 95 standard says that if the absolute value of pos is greater than bit_size(x), the value is undefined.\n"
"        while (pos > val) {\n"
"            x >>= val;\n"
"            pos -= val;\n"
"        }\n"
"        return x >> pos;\n"
"    }\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T ibclr(T x, int pos) { return x & ~shiftBits<T>(1, pos); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T ibchng(T x, int pos) { return x ^ shiftBits<T>(1, pos); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T ibits(T x, int pos, int size) { return shiftBits<T>(x, -pos) & (shiftBits<T>(1, size) - 1); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T ibset(T x, int pos) { return x | shiftBits<T>(1, pos); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T ishft(T x, int shift) {\n"
"    if (shift >= 0) {\n"
"        return shiftBits<T>(x, shift);\n"
"    } else {\n"
"        shift = -shift - 1;\n"
"        x >>= 1;\n"
"        x = ibclr<T>(x, (sizeof(x) << 3) - 1);\n"
"        return shiftBits<T>(x, -shift);\n"
"    }\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T lshft(T x, int shift) { return ishft<T>(x, shift); }\n"
"\n"
"#ifndef INTEL_LOGICAL_TYPE\n"
"template<typename T>\n"
"__device__ __inline__ T rshft(T x, int shift) { return shiftBits<T>(x, -shift); }\n"
"#else\n"
"template<typename T>\n"
"__device__ __inline__ T rshft(T x, int shift) { return ishft<T>(x, -shift); }\n"
"#endif\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T dshiftl(T l, T r, int shift) {\n"
"    if (shift == 0)\n"
"        return l;\n"
"    else if (shift == (sizeof(T) << 3))\n"
"        return r;\n"
"    else\n"
"        return ishft<T>(l, shift) | ishft<T>(r, shift - (sizeof(r) << 3));\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T dshiftr(T l, T r, int shift) {\n"
"    if (shift == 0)\n"
"        return r;\n"
"    else if (shift == (sizeof(T) << 3))\n"
"        return l;\n"
"    else\n"
"        return ishft<T>(l, (sizeof(l) << 3) - shift) | ishft<T>(r, -shift);\n"
"}\n"
"\n"
"template <typename T>\n"
"__device__ __inline__ T isha(T x, int shift) { return shiftBits<T>(x, shift); }\n"
"\n"
"#ifndef INTEL_LOGICAL_TYPE\n"
"template <typename T>\n"
"__device__ __inline__ T shifta(T x, int shift) { return (shift == (sizeof(x) << 3) ? (x < 0 ? -1 : 0) : isha<T>(x, -shift)); }\n"
"#else\n"
"template <typename T>\n"
"__device__ __inline__ T shifta(T x, int shift) { return (shift == (sizeof(x) << 3) ? 0 : isha<T>(x, -shift)); }\n"
"#endif\n"
"\n"
"#ifndef INTEL_LOGICAL_TYPE\n"
"template <typename T>\n"
"__device__ __inline__ T shiftr(T x, int shift) { return ishft<T>(x, -shift); }\n"
"#else\n"
"template <typename T>\n"
"__device__ __inline__ T shiftr(T x, int shift) { return rshft<T>(x, shift); }\n"
"#endif\n"
"\n"
"template <typename T>\n"
"__device__ __inline__ T ishftc(T x, int shift, int size) {\n"
"    // XXX: Should it be so complex?\n"
"    T delim = shiftBits<T>(1, size - 1);\n"
"    T mask = delim | (delim - 1);\n"
"    T sub = x & mask;\n"
"    if (shift >= 0) {\n"
"        shift %= size;\n"
"        T sign = ((sub & delim) == delim);\n"
"        T count = shift;\n"
"        while (count != 0) {\n"
"            sub = ((sub << 1) & mask) | sign;\n"
"            sign = ((sub & delim) == delim);\n"
"            count--;\n"
"        }\n"
"    } else {\n"
"        shift = (-shift) % size;\n"
"        T sign = ((sub & 1) == 0 ? 0 : delim);\n"
"        T count = shift;\n"
"        while (count != 0) {\n"
"            sub = (((sub >> 1) & mask) & ~delim) | sign;\n"
"            sign = ((sub & 1) == 0 ? 0 : delim);\n"
"            count--;\n"
"        }\n"
"    }\n"
"    return sub | (x & ~mask);\n"
"}\n"
"\n"
"template <typename T>\n"
"__device__ __inline__ T ishc(T x, int shift) { return ishftc<T>(x, shift, (sizeof(x) << 3)); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T ilen(T x) {\n"
"    if (x < 0)\n"
"        x = -x - 1;\n"
"    T i = 0;\n"
"    while (x) {\n"
"        i++;\n"
"        x >>= 1;\n"
"    }\n"
"    return i;\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T popcnt(T x) {\n"
"    T count;\n"
"    if (x >= 0) {\n"
"        count = 0;\n"
"    } else {\n"
"        count = 1;\n"
"        x = ibclr<T>(x, (sizeof(x) << 3) - 1);\n"
"    }\n"
"    while (x != 0) {\n"
"        if ((x & 1) != 0)\n"
"            count++;\n"
"        x >>= 1;\n"
"    }\n"
"    return count;\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T trailz(T x) {\n"
"    T count = 0;\n"
"    while ((x & 1) == 0 && (count < (sizeof(x) << 3))) {\n"
"        count++;\n"
"        x >>= 1;\n"
"    }\n"
"    return count;\n"
"}\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T copysign(T x, T y) { if (x < 0) x = -x; return ((y >= 0) ? x : -x); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T fdim(T x, T y) { return ((x > y) ? (x - y) : 0); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T fmod(T x, T y) { return x % y; }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ T btest(T x, int pos) { return ((x & shiftBits<T>(1, pos)) != 0); }\n"
"\n"
"template<typename T>\n"
"__device__ __inline__ float real(T x) { return (float)x; }\n"
"\n"
"__device__ __inline__ double dprod(float x, float y) { return (double)x * (double)y; }\n"
"\n"
"__device__ __inline__ char abs(char x) { return (char)abs((int)x); }\n"
"__device__ __inline__ short abs(short x) { return (short)abs((int)x); }\n"
"\n"
"#if (__CUDACC_VER_MAJOR__ * 1000 + __CUDACC_VER_MINOR__ * 10 < 7050)\n"
"    __device__ __inline__ long min(long x, long y) { return (long)min((long long)x, (long long)y); }\n"
"    __device__ __inline__ long max(long x, long y) { return (long)max((long long)x, (long long)y); }\n"
"#endif\n"
"\n"
"__device__ __inline__ int min(int x, long long y) { return (int)min((long long)x, y); }\n"
"__device__ __inline__ int min(long long x, int y) { return (int)min(x, (long long)y); }\n"
"__device__ __inline__ int min(long x, int y) { return (int)min(x, (long )y); }\n"
"__device__ __inline__ int max(int x, long long y) { return (int)max((long long)x, y); }\n"
"__device__ __inline__ int max(long long x, int y) { return (int)max(x, (long long)y); }\n"
"__device__ __inline__ int max(long x, int y) { return (int)max(x, (long)y); }\n"
"\n"
"template <typename T>\n"
"class Complex;\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ T real(const Complex<T> &c1)\n"
"{ return c1.x; }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ T imag(const Complex<T> &c1)\n"
"{ return c1.y; }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ T abs(const Complex<T> &c1)\n"
"{ return hypot(c1.x, c1.y); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> conj(const Complex<T> &c1)\n"
"{ return Complex<T>(c1.x, -c1.y); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> sin(const Complex<T> &c1)\n"
"{ return Complex<T>(sin(c1.x) * cosh(c1.y), cos(c1.x) * sinh(c1.y)); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> cos(const Complex<T> &c1)\n"
"{ return Complex<T>(cos(c1.x) * cosh(c1.y), -(sin(c1.x) * sinh(c1.y))); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> tan(const Complex<T> &c1) {\n"
"    const T sin_x = sin(c1.x), cos_x = cos(c1.x);\n"
"    const T sinh_y = sinh(c1.y), cosh_y = cosh(c1.y);\n"
"    return Complex<T>(sin_x * cosh_y, cos_x * sinh_y) / Complex<T>(cos_x * cosh_y, -(sin_x * sinh_y));\n"
"}\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> ctan(const Complex<T> &c1) {\n"
"    const T sin_x = sin(c1.x), cos_x = cos(c1.x);\n"
"    const T sinh_y = sinh(c1.y), cosh_y = cosh(c1.y);\n"
"    return Complex<T>(cos_x * cosh_y, -(sin_x * sinh_y)) / Complex<T>(sin_x * cosh_y, cos_x * sinh_y);\n"
"}\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> log(const Complex<T> &c1)\n"
"{ return Complex<T>(log(abs(c1)), atan2(c1.y, c1.x)); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> log10(const Complex<T> &c1)\n"
"{ return log(c1) / log(T(10)); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> exp(const Complex<T> &c1) {\n"
"    const T exp_x = exp(c1.x);\n"
"    return Complex<T>(exp_x * cos(c1.y), exp_x * sin(c1.y));\n"
"}\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> sqrt(const Complex<T> &c1) {\n"
"    T a, x, y;\n"
"    a = hypot(c1.x, c1.y);\n"
"    if (a == T(0)) {\n"
"        x = T(0);\n"
"        y = T(0);\n"
"    } else if (c1.x > T(0)) {\n"
"        x = sqrt(T(0.5) * (a + c1.x));\n"
"        y = T(0.5) * (c1.y / x);\n"
"    } else {\n"
"        y = sqrt(T(0.5) * (a - c1.x));\n"
"        if (c1.y < T(0))\n"
"            y = -y;\n"
"        x = T(0.5) * (c1.y / y);\n"
"    }\n"
"    return Complex<T>(x, y);\n"
"}\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> pow(const Complex<T> &c1, const T &n) {\n"
"    const T r = pow(abs(c1), n);\n"
"    const T fi = atan2(c1.y, c1.x);\n"
"    return Complex<T>(cos(n * fi) * r, sin(n * fi) * r);\n"
"}\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ float Float(const Complex<T> &c1)\n"
"{ return (float)c1.x; }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ double Double(const Complex<T> &c1)\n"
"{ return (double)c1.x; }\n"
"\n"
"template <typename T>\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"inline __device__ Complex<T> __shfl_down_sync(unsigned mask, const Complex<T> &c1, const unsigned delta) {\n"
"    Complex<T> ret;\n"
"    ret.x = __shfl_down_sync(0xFFFFFF, c1.x, delta);\n"
"    ret.y = __shfl_down_sync(0xFFFFFF, c1.y, delta);\n"
"    return ret;\n"
"}\n"
"#else\n"
"inline __device__ Complex<T> __shfl_down(const Complex<T> &c1, const unsigned delta) {\n"
"\n"
"    Complex<T> ret;\n"
"    ret.x = __shfl_down(c1.x, delta);\n"
"    ret.y = __shfl_down(c1.y, delta);\n"
"    return ret;\n"
"}\n"
"#endif\n"
"\n"
"template <typename T>\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"inline __device__ Complex<T> __shfl_sync(unsigned mask, const Complex<T> &c1, const int src) {\n"
"    Complex<T> ret;\n"
"    ret.x = __shfl_sync(0xFFFFFF, c1.x, src);\n"
"    ret.y = __shfl_sync(0xFFFFFF, c1.y, src);\n"
"    return ret;\n"
"}\n"
"#else\n"
"inline __device__ Complex<T> __shfl(const Complex<T> &c1, const int src) {\n"
"\n"
"    Complex<T> ret;\n"
"    ret.x = __shfl(c1.x, src);\n"
"    ret.y = __shfl(c1.y, src);\n"
"    return ret;\n"
"}\n"
"#endif\n"
"// Arithmetic operators\n"
"\n"
"/// operator +\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator+(const T &left, const Complex<T> &right)\n"
"{ return Complex<T>(left + right.x, right.y); }\n"
"\n"
"/// operator +\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator+(const Complex<T> &left, const T &right)\n"
"{ return Complex<T>(left.x + right, left.y); }\n"
"\n"
"/// operator +\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator+(const Complex<T> &left, const Complex<T> &right)\n"
"{ return Complex<T>(left.x + right.x, left.y + right.y); }\n"
"\n"
"/// operator +\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator+(const Complex<T> &right)\n"
"{ return right; }\n"
"\n"
"/// operator -\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator-(const T &left, const Complex<T> &right)\n"
"{ return Complex<T>(left - right.x, -right.y); }\n"
"\n"
"/// operator -\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator-(const Complex<T> &left, const T &right)\n"
"{ return Complex<T>(left.x - right, left.y); }\n"
"\n"
"/// operator -\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator-(const Complex<T> &left, const Complex<T> &right)\n"
"{ return Complex<T>(left.x - right.x, left.y - right.y); }\n"
"\n"
"/// operator -\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator-(const Complex<T> &right)\n"
"{ return Complex<T>(-right.x, -right.y); }\n"
"\n"
"/// operator *\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator*(const T &left, const Complex<T> &right)\n"
"{ return Complex<T>(right.x * left, right.y * left); }\n"
"\n"
"/// operator *\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator*(Complex<T> &left, const T &right)\n"
"{ return Complex<T>(left.x * right, left.y * right); }\n"
"\n"
"/// operator *\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator*(const Complex<T> &left, const Complex<T> &right)\n"
"{ return Complex<T>(left.x * right.x - left.y * right.y, left.y * right.x + right.y * left.x); }\n"
"\n"
"/// operator /\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator/(const T &left, const Complex<T> &right) {\n"
"    const T down = right.x * right.x + right.y * right.y;\n"
"    return Complex<T>((right.x * left) / down, -(right.y * left) / down);\n"
"}\n"
"\n"
"/// operator /\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator/(const Complex<T> &left, const T& right)\n"
"{ return Complex<T>(left.x / right, left.y / right); }\n"
"\n"
"/// operator /\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator/(const Complex<T> &left, const Complex<T> &right) {\n"
"    const T down = right.x * right.x + right.y * right.y;\n"
"    return Complex<T>((left.x * right.x + left.y * right.y) / down, (left.y * right.x - right.y * left.x) / down);\n"
"}\n"
"\n"
"/// operator ^\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> operator^(const Complex<T> &left, const T &n)\n"
"{ return pow(left, n); }\n"
"\n"
"// assignment operators\n"
"\n"
"/// operator +=\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> &operator+=(Complex<T> &left, const Complex<T> &right)\n"
"{ left.x += right.x; left.y += right.y; return left; }\n"
"\n"
"/// operator *=\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> &operator*=(Complex<T> &left, const Complex<T> &right) {\n"
"    T oldX = left.x, oldY = left.y;\n"
"    left.x = right.x * oldX - right.y * oldY;\n"
"    left.y = right.y * oldX + oldY * right.x;\n"
"    return left;\n"
"}\n"
"\n"
"/// operator -=\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<T> &operator-=(Complex<T> &left, const Complex<T> &right)\n"
"{ left.x -= right.x; left.y -= right.y; return left; }\n"
"\n"
"// comparison operators\n"
"\n"
"/// operator ==\n"
"template <typename T>\n"
"inline __host__ __device__ bool operator==(const Complex<T> &left, const Complex<T> &right)\n"
"{ return (left.x == right.x) && (left.y == right.y); }\n"
"\n"
"/// operator ==\n"
"template <typename T, typename CmpT>\n"
"inline __host__ __device__ bool operator==(const Complex<T> &left, const CmpT &right)\n"
"{ return left == Complex<T>(right); }\n"
"\n"
"/// operator ==\n"
"template <typename T, typename CmpT>\n"
"inline __host__ __device__ bool operator==(const CmpT &left, const Complex<T> &right)\n"
"{ return Complex<T>(left) == right; }\n"
"\n"
"/// operator !=\n"
"template <typename T>\n"
"inline __host__ __device__ bool operator!=(const Complex<T> &left, const Complex<T> &right)\n"
"{ return !(left == right); }\n"
"\n"
"template <>\n"
"class Complex<float> {\n"
"    typedef float T;\n"
"public:\n"
"    T x; ///< Real part of complex number.\n"
"    T y; ///< Imaginary part of complex number.\n"
"public:\n"
"    inline __host__ __device__ Complex() {}\n"
"    inline __host__ __device__ Complex(T x1) //implicit for conversions\n"
"    { x = x1; y = 0; }\n"
"    inline __host__ __device__ Complex(T x1, T y1)\n"
"    { x = x1; y = y1; }\n"
"    template <typename T2>\n"
"    explicit inline __host__ __device__ Complex(const Complex<T2> &other)\n"
"    { x = (T)real(other); y = (T)imag(other); }\n"
"    inline __host__ __device__ Complex &operator=(const Complex<T> &right)\n"
"    { x = right.x; y = right.y; return *this; }\n"
"    template <typename T2>\n"
"    inline __host__ __device__ Complex &operator=(const Complex<T2> &right)\n"
"    { x = (T)real(right); y = (T)imag(right); return *this; }\n"
"#ifdef HAVE_EXPLICIT_CAST\n"
"    explicit\n"
"#endif\n"
"            inline __host__ __device__ operator T() const\n"
"    { return x; }\n"
"#ifdef HAVE_EXPLICIT_CAST\n"
"    explicit inline __host__ __device__ operator double() const\n"
"    { return x; }\n"
"#endif\n"
"};\n"
"\n"
"template <>\n"
"class Complex<double> {\n"
"    typedef double T;\n"
"public:\n"
"    T x; ///< Real part of complex number.\n"
"    T y; ///< Imaginary part of complex number.\n"
"public:\n"
"    inline __host__ __device__ Complex() {}\n"
"    inline __host__ __device__ Complex(T x1) //implicit for conversions\n"
"    { x = x1; y = 0; }\n"
"    inline __host__ __device__ Complex(T x1, T y1)\n"
"    { x = x1; y = y1; }\n"
"    inline __host__ __device__ Complex(const Complex<float> &other) //implicit for propagation\n"
"    { x = (T)real(other); y = (T)imag(other); }\n"
"    inline __host__ __device__ Complex &operator=(const Complex<T> &right)\n"
"    { x = right.x; y = right.y; return *this; }\n"
"#ifdef HAVE_EXPLICIT_CAST\n"
"    explicit\n"
"#endif\n"
"            inline __host__ __device__ operator T() const\n"
"    { return x; }\n"
"#ifdef HAVE_EXPLICIT_CAST\n"
"    explicit inline __host__ __device__ operator float() const\n"
"    { return x; }\n"
"#endif\n"
"};\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<float> cmpxf(const Complex<T> &c1)\n"
"{ return Complex<float>((float)c1.x, (float)c1.y); }\n"
"\n"
"template <typename T>\n"
"inline __host__ __device__ Complex<double> cmpxd(const Complex<T> &c1)\n"
"{ return Complex<double>((double)c1.x, (double)c1.y); }\n"
"\n"
"\n"
"/// Atomic operations\n"
"//Atomic ADD\n"
"__device__ __inline__ float __dvmh_atomic_add(float *addr, float val) { return atomicAdd(addr, val); }\n"
"__device__ __inline__ int __dvmh_atomic_add(int *addr, int val) { return atomicAdd(addr, val); }\n"
"__device__ __inline__ unsigned int __dvmh_atomic_add(unsigned int *addr, unsigned int val) { return atomicAdd(addr, val); }\n"
"__device__ __inline__ unsigned long long __dvmh_atomic_add(unsigned long long *addr, unsigned long long val) { return atomicAdd(addr, val); }\n"
"\n"
"__device__ __inline__ double __dvmh_atomic_add(double *addr, double val) \n"
"{\n"
"#if (__CUDA_ARCH__ < 600)\n"
"    unsigned long long* address_as_ull = (unsigned long long*)addr;\n"
"    unsigned long long old = *address_as_ull, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(address_as_ull, assumed, __double_as_longlong(val + __longlong_as_double(assumed)));\n"
"    // Note: uses integer comparison to avoid hang in case of NaN (since NaN != NaN)\n"
"    } while (assumed != old);\n"
"    return __longlong_as_double(old);\n"
"#else\n"
"    return atomicAdd(addr, val);\n"
"#endif\n"
"}\n"
"\n"
"//Atomic MIN, MAX\n"
"__device__ __inline__ int __dvmh_atomic_min(int *addr, int val) { return atomicMin(addr, val); }\n"
"__device__ __inline__ unsigned int __dvmh_atomic_min(unsigned int *addr, unsigned int val) { return atomicMin(addr, val); }\n"
"\n"
"__device__ __inline__ int __dvmh_atomic_max(int *addr, int val) { return atomicMax(addr, val); }\n"
"__device__ __inline__ unsigned int __dvmh_atomic_max(unsigned int *addr, unsigned int val) { return atomicMax(addr, val); }\n"
"\n"
"__device__ __inline__ unsigned long long __dvmh_atomic_min(unsigned long long *addr, unsigned long long val) \n"
"{\n"
"#if (__CUDA_ARCH__ < 350)\n"
"    unsigned long long old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(addr, assumed, min(val, assumed));\n"
"    } while (assumed != old);\n"
"    return old;\n"
"#else   \n"
"    return atomicMin(addr, val); \n"
"#endif\n"
"}\n"
"\n"
"__device__ __inline__ long long __dvmh_atomic_min(long long *addr, long long val) \n"
"{\n"
"#if (__CUDA_ARCH__ < 350)\n"
"    long long old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = (long long)atomicCAS((unsigned long long*)addr, (unsigned long long)assumed, (unsigned long long)min(val, assumed));\n"
"    } while (assumed != old);\n"
"    return old;\n"
"#else\n"
"    return atomicMin(addr, val); \n"
"#endif\n"
"}\n"
"\n"
"__device__ __inline__ unsigned long long __dvmh_atomic_max(unsigned long long *addr, unsigned long long val) \n"
"{\n"
"#if (__CUDA_ARCH__ < 350)\n"
"    unsigned long long old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(addr, assumed, max(val, assumed));\n"
"    } while (assumed != old);\n"
"    return old;\n"
"#else\n"
"    return atomicMax(addr, val); \n"
"#endif\n"
"}\n"
"\n"
"__device__ __inline__ long long __dvmh_atomic_max(long long *addr, long long val) \n"
"{\n"
"#if (__CUDA_ARCH__ < 350)\n"
"    long long old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = (long long)atomicCAS((unsigned long long*)addr, (unsigned long long)assumed, (unsigned long long)max(val, assumed));\n"
"    } while (assumed != old);\n"
"    return old;\n"
"#else\n"
"    return atomicMax(addr, val); \n"
"#endif\n"
"}\n"
"\n"
"__device__ __inline__ float __dvmh_atomic_min(float *addr, float val) \n"
"{\n"
"    float old = (val >= 0) ? \n"
"                __int_as_float(atomicMin((int *)addr, __float_as_int(val))) : \n"
"                __uint_as_float(atomicMax((unsigned int *)addr, __float_as_uint(val)));\n"
"    return old;\n"
"}\n"
"\n"
"__device__ __inline__ float __dvmh_atomic_max(float *addr, float val) \n"
"{\n"
"    float old = (val >= 0) ? \n"
"                __int_as_float(atomicMax((int *)addr, __float_as_int(val))) : \n"
"                __uint_as_float(atomicMin((unsigned int *)addr, __float_as_uint(val)));\n"
"    return old;\n"
"}\n"
"\n"
"__device__ __inline__ double __dvmh_atomic_min(double *addr, double val) \n"
"{\n"
"    double old = (val >= 0) ? \n"
"                 __longlong_as_double(__dvmh_atomic_min((long long *)addr, __double_as_longlong(val))) : \n"
"                 __longlong_as_double(__dvmh_atomic_max((unsigned long long *)addr, (unsigned long long) __double_as_longlong(val)));\n"
"    return old;\n"
"}\n"
"\n"
"__device__ __inline__ double __dvmh_atomic_max(double *addr, double val) \n"
"{\n"
"    double old = (val >= 0) ? \n"
"                 __longlong_as_double(__dvmh_atomic_max((long long *)addr, __double_as_longlong(val))) : \n"
"                 __longlong_as_double(__dvmh_atomic_min((unsigned long long *)addr, (unsigned long long) __double_as_longlong(val)));\n"
"    return old;\n"
"}\n"
"\n"
"//Atomic prod, TODO\n"
"__device__ __inline__ int __dvmh_atomic_prod(int *addr, int val) \n"
"{\n"
"    int old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(addr, assumed, val * assumed);\n"
"    } while (assumed != old);\n"
"    return old;\n"
"}\n"
"\n"
"__device__ __inline__ long long __dvmh_atomic_prod(unsigned long long *addr, unsigned long long val) \n"
"{\n"
"    unsigned long long old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(addr, assumed, val * assumed);\n"
"    } while (assumed != old);\n"
"    return old;\n"
"}\n"
"\n"
"__device__ __inline__ float __dvmh_atomic_prod(float *addr, float val) { return 0; }\n"
"__device__ __inline__ float __dvmh_atomic_prod(double *addr, double val) { return 0; }\n"
"\n"
"//Atomic Bitwise\n"
"__device__ __inline__ int __dvmh_atomic_and(int *addr, int val) { return atomicAnd(addr, val); }\n"
"__device__ __inline__ int __dvmh_atomic_or(int *addr, int val) { return atomicOr(addr, val); }\n"
"__device__ __inline__ int __dvmh_atomic_neqv(int *addr, int val) \n"
"{\n"
"    int old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(addr, assumed, (old != val));\n"
"    } while (assumed != old);\n"
"    return old;\n"
"}\n"
"\n"
"__device__ __inline__ int __dvmh_atomic_eqv(int *addr, int val) \n"
"{\n"
"    int old = *addr, assumed;\n"
"    do \n"
"    {\n"
"        assumed = old;\n"
"        old = atomicCAS(addr, assumed, (old == val));\n"
"    } while (assumed != old);\n"
"    return old;\n"
"}\n"
"\n"
"//simple XOR_SHIFT random (rng_xor128)\n"
"template<typename dType>\n"
"__device__ __inline__ void __dvmh_rand(dType &retVal, uint4 &state)\n"
"{\n"
"    unsigned int t;\n"
"    t = state.x ^ (state.x << 11);\n"
"\n"
"    state.x = state.y;\n"
"    state.y = state.z;\n"
"    state.z = state.w;\n"
"\n"
"    state.w = (state.w ^ (state.w >> 19)) ^ (t ^ (t >> 8));\n"
"    retVal = (dType)state.w / (dType)UINT_MAX;\n"
"}\n"
"\n"
;
static const std::string dvmhlib_block_red = 
"\n"
"\n"
"template<typename T, typename I, int numI>\n"
"__inline__ __device__ void __dvmh_blockReduceDummyLoc(T &val, I *index)\n"
"{ }\n"
"\n"
"#ifndef CUDA_FERMI_ARCH\n"
"\n"
"// minloc && maxloc operations\n"
"template<typename T, typename I, void func(T &val, I *index)>\n"
"__inline__ __device__ void __dvmh_blockReduceLoc(T &val, I *index)\n"
"{ func(val, index); }\n"
"\n"
"// single and multiple element operations\n"
"template<typename T, void func(T *val)>\n"
"__inline__ __device__ void __dvmh_blockReduceN(T *val)\n"
"{ return func(val); }\n"
"template<typename T, T func(T &A)>\n"
"__inline__ __device__ T __dvmh_blockReduce(T &val, bool withBcast = false)\n"
"{ \n"
"    if (withBcast)\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"        return __shfl_sync(0xFFFFFFFF, func(val), 0);\n"
"#else\n"
"        return __shfl(func(val), 0);\n"
"#endif\n"
"    else\n"
"        return func(val); \n"
"}\n"
"\n"
"// for arrays of unknown size\n"
"template<typename T, typename CE, typename N, void func(T *val, CE coef, N num)>\n"
"__inline__ __device__ void __dvmh_blockReduceN(T *val, CE coef, N num)\n"
"{ return func(val, coef, num); }\n"
"\n"
"\n"
"\n"
"template<typename T, typename I, int numI>\n"
"__inline__ __device__ void __dvmh_blockReduceMinLoc(T &val, I *index)\n"
"{ __dvmh_blockReduceLoc<T, I, __dvmh_warpReduceScalarLoc<T, I, numI, minloc_<T, I, numI> > >(val, index); }\n"
"template<typename T, typename I, int numI>\n"
"__inline__ __device__ void __dvmh_blockReduceMaxLoc(T &val, I *index)\n"
"{ __dvmh_blockReduceLoc<T, I, __dvmh_warpReduceScalarLoc<T, I, numI, maxloc_<T, I, numI> > >(val, index); }\n"
"\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceMinN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, min_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceMaxN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, max_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceANDN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, and_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceORN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, or_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceNEQN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, neq_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceEQN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, eq_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceProdN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, prod_, num> >(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceSumN(T *val)\n"
"{ __dvmh_blockReduceN<T, __dvmh_warpReduceScalarN<T, sum_, num> >(val); }\n"
"\n"
"// for arrays of unknown size, 1D\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceMinN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, min_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceMaxN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, max_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceANDN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, and_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceORN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, or_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceNEQN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, neq_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceEQN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, eq_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceProdN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, prod_> >(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceSumN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_warpReduceScalarN<T, CE, N, sum_> >(val, coef, num); }\n"
"\n"
"#else\n"
"\n"
"extern __shared__ char shMem[];\n"
"\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceMin(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceMax(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceAND(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceOR(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceNEQ(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceEQ(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceProd(T val);\n"
"template<typename T> __inline__ __device__ T __dvmh_blockReduceSum(T val);\n"
"\n"
"template<typename T, void func(T *val, T &fin, const unsigned idx, const int lane)>\n"
"__inline__ __device__ T __dvmh_blockReduce(T val, bool withBcast = false)\n"
"{\n"
"    unsigned idx = threadIdx.x + threadIdx.y * blockDim.x + threadIdx.z * blockDim.x * blockDim.y;\n"
"    T *shared = (T*)shMem;\n"
"    int lane = idx % warpSize;\n"
"\n"
"    shared[idx] = val;\n"
"    __syncthreads();\n"
"    func(shared, val, idx, lane);\n"
"    __syncthreads();\n"
"    return val;\n"
"}\n"
"\n"
"template<typename T, int num, T func(T A)>\n"
"__inline__ __device__ void __dvmh_blockReduceN(T *val)\n"
"{\n"
"#pragma unroll\n"
"    for (int i = 0; i < num; ++i)\n"
"        val[i] = func(val[i]);\n"
"}\n"
"\n"
"template<typename T, typename CE, typename N, T func(T A)>\n"
"__inline__ __device__ void __dvmh_blockReduceN(T *val, CE coef, N num)\n"
"{\n"
"#pragma unroll\n"
"    for (int i = 0; i < num; ++i)\n"
"        val[i * coef] = func(val[i * coef]);\n"
"}\n"
"\n"
"template<typename T, typename I, int numI, void func(T *val, I *index, const unsigned idx, const int lane)>\n"
"__inline__ __device__ void __dvmh_blockReduceLoc(T &val, I *index)\n"
"{\n"
"    unsigned idx = threadIdx.x + threadIdx.y * blockDim.x + threadIdx.z * blockDim.x * blockDim.y;\n"
"    unsigned blockDims = blockDim.x * blockDim.y * blockDim.z;\n"
"    int lane = idx % warpSize;\n"
"    T *shared = (T*)shMem;\n"
"    I *sharedIdx = (I*)&shared[blockDims];\n"
"\n"
"    shared[idx] = val;\n"
"#pragma unroll\n"
"    for (int i = 0; i < numI; ++i)\n"
"        sharedIdx[numI * idx + i] = index[i];\n"
"    __syncthreads();\n"
"    func(shared, sharedIdx, idx, lane);\n"
"    __syncthreads();\n"
"    if (lane == 0)\n"
"    {\n"
"        val = shared[idx];\n"
"#pragma unroll\n"
"        for (int i = 0; i < numI; ++i)\n"
"            index[i] = sharedIdx[numI * idx + i];\n"
"    }\n"
"}\n"
"\n"
"template<typename T, typename I, int numI>\n"
"__inline__ __device__ void __dvmh_blockReduceMinLoc(T &val, I *index)\n"
"{ __dvmh_blockReduceLoc<T, I, numI, __dvmh_warpReduceScalarLoc<T, I, numI, minloc_<T, I, numI> > >(val, index); }\n"
"template<typename T, typename I, int numI>\n"
"__inline__ __device__ void __dvmh_blockReduceMaxLoc(T &val, I *index)\n"
"{ __dvmh_blockReduceLoc<T, I, numI, __dvmh_warpReduceScalarLoc<T, I, numI, maxloc_<T, I, numI> > >(val, index); }\n"
"\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceMinN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceMin>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceMaxN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceMax>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceANDN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceAND>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceORN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceOR>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceNEQN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceNEQ>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceEQN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceEQ>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceProdN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceProd>(val); }\n"
"template<typename T, int num>\n"
"__inline__ __device__ void __dvmh_blockReduceSumN(T *val)\n"
"{ __dvmh_blockReduceN<T, num, __dvmh_blockReduceSum>(val); }\n"
"\n"
"// for arrays of unknown size, 1D\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceMinN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceMin>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceMaxN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceMax>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceANDN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceAND>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceORN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceOR>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceNEQN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceNEQ>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceEQN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceEQ>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceProdN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceProd>(val, coef, num); }\n"
"template<typename T, typename CE, typename N>\n"
"__inline__ __device__ void __dvmh_blockReduceSumN(T *val, CE coef, N num)\n"
"{ __dvmh_blockReduceN<T, CE, N, __dvmh_blockReduceSum>(val, coef, num); }\n"
"\n"
"#endif\n"
"\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceMin(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, min_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceMax(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, max_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceAND(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, and_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceOR(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, or_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceNEQ(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, neq_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceEQ(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, eq_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceProd(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, prod_> >(val); }\n"
"template<typename T>\n"
"__inline__ __device__ T __dvmh_blockReduceSum(T val)\n"
"{ return __dvmh_blockReduce<T, __dvmh_warpReduceScalar<T, sum_> >(val); }\n"
"\n"
;
static const std::string dvmhlib_warp_red = 
"\n"
"#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n"
"#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n"
"\n"
"template<typename T>\n"
"inline __device__ void sum_(T &A, const T &B) { A += B; }\n"
"template<typename T>\n"
"inline __device__ void prod_(T &A, const T &B) { A *= B; }\n"
"template<typename T>\n"
"inline __device__ void max_(T &A, const T &B) { A = MAX(A, B); }\n"
"template<typename T>\n"
"inline __device__ void min_(T &A, const T &B) { A = MIN(A, B); }\n"
"template<typename T>\n"
"inline __device__ void or_(T &A, const T &B) { A |= B; }\n"
"template<typename T>\n"
"inline __device__ void and_(T &A, const T &B) { A &= B; }\n"
"#ifdef INTEL_LOGICAL_TYPE\n"
"template<typename T>\n"
"inline __device__ void eq_(T &A, const T &B) { A = ~(A ^ B); }\n"
"template<typename T>\n"
"inline __device__ void neq_(T &A, const T &B) { A ^= B; }\n"
"#else\n"
"template<typename T>\n"
"inline __device__ void eq_(T &A, const T &B) { A = (A == B); }\n"
"template<typename T>\n"
"inline __device__ void neq_(T &A, const T &B) { A = (A != B); } \n"
"#endif\n"
"\n"
"template<typename T, typename I, int numI>\n"
"inline __device__ void maxloc_(T &A, I *Aidx, const T &B, const I *Bidx) {\n"
"    if (B > A) {\n"
"        A = B;\n"
"#pragma unroll\n"
"        for (unsigned i = 0; i < numI; i++)\n"
"            Aidx[i] = Bidx[i];\n"
"    }\n"
"}\n"
"template<typename T, typename I, int numI>\n"
"inline __device__ void minloc_(T &A, I *Aidx, const T &B, const I *Bidx) {\n"
"    if (B < A) {\n"
"        A = B;\n"
"#pragma unroll\n"
"        for (unsigned i = 0; i < numI; ++i)\n"
"            Aidx[i] = Bidx[i];\n"
"    }\n"
"}\n"
"\n"
"template<typename T, typename I, int numI>\n"
"inline __device__ void dummyloc_(T &A, I *Aidx, const T &B, const I *Bidx)\n"
"{ }\n"
"\n"
"#ifndef CUDA_FERMI_ARCH\n"
"template<typename T, void func(T &A, const T&B)>\n"
"inline __device__ void func_and_shfl_down(T &val, const int delta)\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"{   func(val, __shfl_down_sync(0xFFFFFFFF, val, (unsigned)delta)); }\n"
"#else\n"
"{   func(val, __shfl_down(val, (unsigned)delta)); }\n"
"#endif\n"
"\n"
"template<typename T, typename I, int numI, void func(T &A, I *B, const T&A1, const I *B1)>\n"
"__inline__ __device__ void __dvmh_warpReduceScalarLoc(T &val, I *index)\n"
"{\n"
"    T local;\n"
"    I idx[numI];\n"
"#pragma unroll\n"
"    for (int offset = warpSize / 2; offset > 0; offset /= 2)\n"
"    {\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"        local = __shfl_down_sync(0xFFFFFFFF, val, (unsigned)offset);\n"
"#else\n"
"        local = __shfl_down(val, (unsigned)offset);\n"
"#endif\n"
"#pragma unroll\n"
"        for (int i = 0; i < numI; ++i)\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"            idx[i] = __shfl_down_sync(0xFFFFFFFF,index[i], (unsigned)offset);\n"
"#else\n"
"            idx[i] = __shfl_down(index[i], (unsigned)offset);\n"
"#endif\n"
"        func(val, index, local, idx);\n"
"    }\n"
"}\n"
"\n"
"template<typename T, void func(T &A, const T &B), int num>\n"
"__inline__ __device__ void __dvmh_warpReduceScalarN(T *val)\n"
"{\n"
"#pragma unroll\n"
"    for (int offset = warpSize / 2; offset > 0; offset /= 2)\n"
"#pragma unroll\n"
"        for (int i = 0; i < num; ++i)\n"
"            func_and_shfl_down<T, func>(val[i], offset);\n"
"}\n"
"\n"
"template<typename T, typename CE, typename N, void func(T &A, const T &B)>\n"
"__inline__ __device__ void __dvmh_warpReduceScalarN(T *val, CE coef, N num)\n"
"{\n"
"#pragma unroll\n"
"    for (int offset = warpSize / 2; offset > 0; offset /= 2)\n"
"#pragma unroll\n"
"        for (int i = 0; i < num; ++i)\n"
"            func_and_shfl_down<T, func>(val[i * coef], offset);\n"
"}\n"
"\n"
"template<typename T, void func(T &A, const T &B)>\n"
"__inline__ __device__ T __dvmh_warpReduceScalar(T &val)\n"
"{\n"
"#pragma unroll\n"
"    for (int offset = warpSize / 2; offset > 0; offset /= 2)\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"        func(val, __shfl_down_sync(0xFFFFFFFF, val, (unsigned)offset));\n"
"#else\n"
"        func(val, __shfl_down(val, (unsigned)offset));\n"
"#endif\n"
"    return val;\n"
"}\n"
"\n"
"template<typename T, typename I>\n"
"__inline__ __device__ T __dvmh_warpBroadcast(const T val, const I index)\n"
"{\n"
"#if __CUDACC_VER_MAJOR__ >= 9\n"
"        return __shfl_sync(0xFFFFFFFF, val, index);\n"
"#else\n"
"        return __shfl(val, index);\n"
"#endif\n"
"}\n"
"\n"
"#else\n"
"\n"
"template<typename T, typename I, int numI, void func(T &A, I *B, const T&A1, const I *B1)>\n"
"__inline__ __device__ void __dvmh_warpReduceScalarLoc(T *val, I *index, const unsigned idx, const int lane)\n"
"{\n"
"    if (lane < 16)\n"
"        func(val[idx], index + numI * idx, val[idx + 16], index + numI * (idx + 16));\n"
"    if (lane < 8)\n"
"        func(val[idx], index + numI * idx, val[idx + 8], index + numI * (idx + 8));\n"
"    if (lane < 4)\n"
"        func(val[idx], index + numI * idx, val[idx + 4], index + numI * (idx + 4));\n"
"    if (lane < 2)\n"
"        func(val[idx], index + numI * idx, val[idx + 2], index + numI * (idx + 2));\n"
"    if (lane < 1)\n"
"        func(val[idx], index + numI * idx, val[idx + 1], index + numI * (idx + 1));\n"
"}\n"
"\n"
"template<typename T, void func(T &A, const T &B)>\n"
"__inline__ __device__ void __dvmh_warpReduceScalar(T *val, T &fin, const unsigned idx, const int lane)\n"
"{\n"
"    if (lane < 16)\n"
"        func(val[idx], val[idx + 16]);\n"
"    if (lane < 8)\n"
"        func(val[idx], val[idx + 8]);\n"
"    if (lane < 4)\n"
"        func(val[idx], val[idx + 4]);\n"
"    if (lane < 2)\n"
"        func(val[idx], val[idx + 2]);\n"
"    if (lane < 1)\n"
"    {\n"
"        func(val[idx], val[idx + 1]);\n"
"        fin = val[idx];\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#undef MIN\n"
"#undef MAX\n"
"\n"
;
static const std::string dvmhlib_device = 
"// Place for supplementary __device__ function definitions\n"
"\n"
"template<typename IndexT, int slash, int cmp_X_Y>\n"
"__forceinline__ __device__ void dvmh_convert_XY(const IndexT x, const IndexT y, const IndexT Rx, const IndexT Ry, IndexT &idx) {\n"
"    if (slash == 0) {\n"
"        if (cmp_X_Y == 0) {\n"
"            if (x + y < Rx)\n"
"                idx = y + (1 + x + y)*(x + y) / 2;\n"
"            else\n"
"                idx = Rx*(Rx - 1) + x - (2 * Rx - x - y - 1)*(2 * Rx - x - y - 2) / 2;\n"
"        } else if (cmp_X_Y == 1) {\n"
"            if (x + y < Rx)\n"
"                idx = y + ((1 + x + y)*(x + y)) / 2;\n"
"            else if (x + y < Ry)\n"
"                idx = ((1 + Rx)*Rx) / 2 + Rx - x - 1 + Rx * (x + y - Rx);\n"
"            else\n"
"                idx = Rx*Ry - Ry + y - (((Rx + Ry - y - x - 1)* (Rx + Ry - y - x - 2)) / 2);\n"
"        } else {\n"
"            if (x + y < Ry)\n"
"                idx = x + (1 + x + y)*(x + y) / 2;\n"
"            else if (x + y < Rx)\n"
"                idx = (1 + Ry)*Ry / 2 + (Ry - y - 1) + Ry * (x + y - Ry);\n"
"            else\n"
"                idx = Rx*Ry - Rx + x - ((Rx + Ry - y - x - 1)* (Rx + Ry - y - x - 2) / 2);\n"
"        }\n"
"    } else {\n"
"        if (cmp_X_Y == 0) {\n"
"            if (x + Rx - 1 - y < Rx)\n"
"                idx = Rx - 1 - y + (x + Rx - y)*(x + Rx - 1 - y) / 2;\n"
"            else\n"
"                idx = Rx*(Rx - 1) + x - (Rx - x + y)*(Rx - x + y - 1) / 2;\n"
"        } else if (cmp_X_Y == 1) {\n"
"            if (x + Ry - 1 - y < Rx)\n"
"                idx = Ry - 1 - y + ((x + Ry - y)*(x + Ry - 1 - y)) / 2;\n"
"            else if (x + Ry - 1 - y < Ry)\n"
"                idx = ((1 + Rx)*Rx) / 2 + Rx - x - 1 + Rx * (x + Ry - 1 - y - Rx);\n"
"            else\n"
"                idx = Rx*Ry - 1 - y - (((Rx + y - x)* (Rx + y - x - 1)) / 2);\n"
"        } else {\n"
"            if (x + Ry - 1 - y < Ry)\n"
"                idx = x + (1 + x + Ry - 1 - y)*(x + Ry - 1 - y) / 2;\n"
"            else if (x + Ry - 1 - y < Rx)\n"
"                idx = (1 + Ry)*Ry / 2 + y + Ry * (x - y - 1);\n"
"            else\n"
"                idx = Rx*Ry - Rx + x - ((Rx + y - x)* (Rx + y - x - 1) / 2);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"template<typename IndexT>\n"
"__inline__ __device__ void dvmh_convert_XY(const IndexT x, const IndexT y, const IndexT Rx, const IndexT Ry, const int slash, IndexT &idx) {\n"
"    if (!slash) {\n"
"        if (Rx == Ry) {\n"
"            if (x + y < Rx)\n"
"                idx = y + (1 + x + y)*(x + y) / 2;\n"
"            else\n"
"                idx = Rx*(Rx - 1) + x - (2 * Rx - x - y - 1)*(2 * Rx - x - y - 2) / 2;\n"
"        } else if (Rx < Ry) {\n"
"            if (x + y < Rx)\n"
"                idx = y + ((1 + x + y)*(x + y)) / 2;\n"
"            else if (x + y < Ry)\n"
"                idx = ((1 + Rx)*Rx) / 2 + Rx - x - 1 + Rx * (x + y - Rx);\n"
"            else\n"
"                idx = Rx*Ry - Ry + y - (((Rx + Ry - y - x - 1)* (Rx + Ry - y - x - 2)) / 2);\n"
"        } else {\n"
"            if (x + y < Ry)\n"
"                idx = x + (1 + x + y)*(x + y) / 2;\n"
"            else if (x + y < Rx)\n"
"                idx = (1 + Ry)*Ry / 2 + (Ry - y - 1) + Ry * (x + y - Ry);\n"
"            else\n"
"                idx = Rx*Ry - Rx + x - ((Rx + Ry - y - x - 1)* (Rx + Ry - y - x - 2) / 2);\n"
"        }\n"
"    } else {\n"
"        if (Rx == Ry) {\n"
"            if (x + Rx - 1 - y < Rx)\n"
"                idx = Rx - 1 - y + (x + Rx - y)*(x + Rx - 1 - y) / 2;\n"
"            else\n"
"                idx = Rx*(Rx - 1) + x - (Rx - x + y)*(Rx - x + y - 1) / 2;\n"
"        } else if (Rx < Ry) {\n"
"            if (x + Ry - 1 - y < Rx)\n"
"                idx = Ry - 1 - y + ((x + Ry - y)*(x + Ry - 1 - y)) / 2;\n"
"            else if (x + Ry - 1 - y < Ry)\n"
"                idx = ((1 + Rx)*Rx) / 2 + Rx - x - 1 + Rx * (x + Ry - 1 - y - Rx);\n"
"            else\n"
"                idx = Rx*Ry - 1 - y - (((Rx + y - x)* (Rx + y - x - 1)) / 2);\n"
"        } else {\n"
"            if (x + Ry - 1 - y < Ry)\n"
"                idx = x + (1 + x + Ry - 1 - y)*(x + Ry - 1 - y) / 2;\n"
"            else if (x + Ry - 1 - y < Rx)\n"
"                idx = (1 + Ry)*Ry / 2 + y + Ry * (x - y - 1);\n"
"            else\n"
"                idx = Rx*Ry - Rx + x - ((Rx + y - x)* (Rx + y - x - 1) / 2);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
;
static const std::string pgi_include = 
"\n"
;
