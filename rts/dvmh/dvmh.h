#include "dvmlib_incs.h"

// TODO: Leave only this include, move comments in the Doxygen format to include/dvmhlib*.h files
#include "include/dvmhlib.h"

#pragma GCC visibility push(default)
extern "C" {

// Окончание работы.
void dvmh_finish_();


// Запросы актуализации на хост
// Запрос на актуализацию данных на хост-системе. Первый параметр – массив. Второй – массив нижних индексов. Третий – массив верхних индексов. Значение индекса -2147483648 означает открытую границу (то есть до конца конкретного измерения с конкретной стороны имеющегося у этого процесса части пространства массива (локальная часть + теневые грани)).
void dvmh_get_actual_subvariable_(void *addr, DvmType lowIndex[], DvmType highIndex[]);

// Запрос на актуализацию данных на хост-системе. Параметр – скалярная переменная или обычный массив.
void dvmh_get_actual_variable_(void *addr);

// Запрос на актуализацию данных на хост-системе. Первый параметр – заголовочный массив. Второй – массив нижних индексов. Третий – массив верхних индексов. Значение индекса -2147483648 означает открытую границу (то есть до конца конкретного измерения с конкретной стороны имеющегося у этого процесса части пространства массива (локальная часть + теневые грани)).
void dvmh_get_actual_subarray_(DvmType dvmDesc[], DvmType lowIndex[], DvmType highIndex[]);

// Запрос на актуализацию данных на хост-системе. Первый параметр – заголовочный массив. Распространяется на весь массив целиком (локальная часть + теневые грани).
void dvmh_get_actual_array_(DvmType dvmDesc[]);

// Запрос на актуализацию всех данных на хост-системе.
void dvmh_get_actual_all_();


// Объявление актуальности на хосте
// Объявление актуальности данных на хост-системе. Первый параметр – массив. Второй – массив нижних индексов. Третий – массив верхних индексов. Значение индекса -2147483648 означает открытую границу (то есть до конца конкретного измерения с конкретной стороны имеющейся у этого процесса локальной части массива).
void dvmh_actual_subvariable_(void *addr, DvmType lowIndex[], DvmType highIndex[]);

// Объявление актуальности данных на хост-системе. Параметр – скалярная переменная или обычный массив.
void dvmh_actual_variable_(void *addr);

// Объявление актуальности данных на хост-системе. Первый параметр – заголовочный массив. Второй – массив нижних индексов. Третий – массив верхних индексов. Значение индекса -2147483648 означает открытую границу (то есть до конца конкретного измерения с конкретной стороны имеющейся у этого процесса локальной части массива).
void dvmh_actual_subarray_(DvmType dvmDesc[], DvmType lowIndex[], DvmType highIndex[]);

// Объявление актуальности данных на хост-системе. Первый параметр – заголовочный массив. Распространяется на всю имеющуюся у этого процесса локальную часть массива.
void dvmh_actual_array_(DvmType dvmDesc[]);

// Объявление актуальности всех данных на хост-системе.
void dvmh_actual_all_();


// Вспомогательные функции для поддержки DVM-директив
// Обеспечение актуальных данных на хосте перед передачей другим процессам по директиве REMOTE_ACCESS. Вызывать и внутри и вне региона непосредственно перед loadrb_. Единственный параметр - заголовочный массив буфера удаленных элементов.
void dvmh_remote_access_(DvmType dvmDesc[]);

// Обеспечение SHADOW_RENEW. Вызывать единожды перед strtsh_. Первый параметр – теневая группа. Вызывать и внутри и вне региона.
void dvmh_shadow_renew_(ShadowGroupRef *group);

// Оповещение о намерении перераспределить массив. Вызывать для массивов, включенных в REDISTRIBUTE непосредственно перед DVM-обработкой.
void dvmh_redistribute_(DvmType dvmDesc[], DvmType *newValueFlagRef);

// Оповещение о намерении перевыровнять массив. Вызывать для массивов, включенных в REALIGN непосредственно перед DVM-обработкой.
void dvmh_realign_(DvmType dvmDesc[], DvmType *newValueFlagRef);


// Уничтожение переменных
// Оповещение о фактическом прекращении существования переменной. Вызывать непосредственно перед выходом из подпрограммы для локальных переменных, а также перед deallocate.
void dvmh_destroy_variable_(void *addr);

// Оповещение о фактическом прекращении существования переменной-массива. Вызывать непосредственно перед выходом из подпрограммы для локальных переменных, а также перед deallocate.
void dvmh_destroy_array_(DvmType dvmDesc[]);


// Сервисные функции для вызова из обработчиков
// Возвращает адрес на устройстве для переменной.
void *dvmh_get_device_addr(DvmType *deviceRef, void *variable);

// Вычисляет смещение представителя скалярной переменной или обычного массива на заданном устройстве по заданной базе. Параметры: устройство, база, переменная скалярная или обычный массив.
DvmType dvmh_calculate_offset_(DvmType *deviceRef, void *base, void *variable);

// Вычисляет естественную базу для массива. Это такая база, при использовании которой смещение равно нулю.
void *dvmh_get_natural_base(DvmType *deviceRef, DvmType dvmDesc[]);

// Заполняет урезанный DVM-заголовочный массив для представителя на заданном устройстве в соответствии с указанной базой. Параметры: устройство, база, заголовочный массив, массив для вновь заполненного заголовка для конкретного устройства.
void dvmh_fill_header_(DvmType *deviceRef, void *base, DvmType dvmDesc[], DvmType dvmhDesc[]);

// Заполняет урезанный DVM-заголовочный массив для представителя на заданном устройстве в соответствии с указанной базой. Параметры: устройство, база, заголовочный массив, массив для вновь заполненного заголовка для конкретного устройства, выходной параметр для извещения о текущем виде представителя массива, массив для получения дополнительных параметров адресации массива в случае наличия сложной трансформации представителя массива на данном устройстве.
// Тип трансформации:
// 0 - нет трансформации. Элемент dvmhDesc[rank] = 1, extendedParams не заполняется
// 1 - перестановка измерений. Элемент dvmhDesc[rank] != 1, extendedParams не заполняется
// 2 - перестановка измерений + диагонализация. Два элемента dvmhDesc зануляются, extendedParams заполняется следующим образом:
//     extendedParams[0] = номер измерения 'x'; // отсчет с единицы, dvmhDesc[extendedParams[0]] = 0
//     extendedParams[1] = начальный индекс по измерению 'x';
//     extendedParams[2] = длина по измерению 'x';
//     extendedParams[3] = номер измерения 'y'; // отсчет с единицы, dvmhDesc[extendedParams[3]] = 0
//     extendedParams[4] = начальный индекс по измерению 'y';
//     extendedParams[5] = длина по измерению 'y';
//     extendedParams[6] = признак направления диагоналей; // 0 - параллельно побочной, 1 - параллельно главной
void dvmh_fill_header_ex_(DvmType *deviceRef, void *base, DvmType dvmDesc[], DvmType dvmhDesc[], DvmType *outTypeOfTransformation,
        DvmType extendedParams[]);


// Регионы
// Создание региона. Параметр – флаги региона. Побитовое объединение из (REGION_ASYNC = 1, REGION_COMPARE_DEBUG = 2).
DvmType region_create_(DvmType *flagsRef);

// Регистрация подмассива в регионе. Первый параметр – ссылка на регион, которую вернул вызов region_create_(). Второй параметр – направление использования (1 – in, 2 – out, 4 – local, 3 – inout, 5 - inlocal). Третий параметр – заголовочный массив. Четвертый параметр – массив нижних индексов. Пятый параметр – массив верхних индексов. Значение индекса -2147483648 означает открытую границу (то есть до конца конкретного измерения с конкретной стороны (для in - локальная часть + теневые грани, для out и local - только локальная часть)). Шестой параметр - тип, выбирается из набора констант rt_XXX, можно задавать "неизвестный" тип как (-1).
void region_register_subarray_(DvmType *regionRef, DvmType *intentRef, DvmType dvmDesc[], DvmType lowIndex[], DvmType highIndex[],
        DvmType *elemType);

// Регистрация массива в регионе. Первый параметр – ссылка на регион, которую вернул вызов region_create_(). Второй параметр – направление использования (1 – in, 2 – out, 4 – local, 3 – inout, 5 - inlocal). Третий параметр – заголовочный массив. Распространяется на весь массив (для in - локальная часть + теневые грани, для out и local - только локальная часть). Четвертый параметр - тип, выбирается из набора констант rt_XXX, можно задавать "неизвестный" тип как (-1).
void region_register_array_(DvmType *regionRef, DvmType *intentRef, DvmType dvmDesc[], DvmType *elemType);

// Регистрация скаляра в регионе. Первый параметр – ссылка на регион, которую вернул вызов region_create_(). Второй параметр – направление использования (1 – in, 2 – out, 4 – local, 3 – inout, 5 - inlocal). Третий параметр – скалярная переменная. Четвертый параметр – размер скаляра (4 для float, 8 для double, и т.п.). Пятый параметр - тип, выбирается из набора констант rt_XXX, можно задавать "неизвестный" тип как (-1).
void region_register_scalar_(DvmType *regionRef, DvmType *intentRef, void *addr, DvmType *sizeRef, DvmType *varType);

// Регистрация имени переменной в текущем регионе
void region_set_name_array_(DvmType *regionRef, DvmType dvmDesc[], const char *name, int nameLength);
void region_set_name_variable_(DvmType *regionRef, void *addr, const char *name, int nameLength);

// Указание целевого набора типов устройств для выполнения региона, завершение регистраций и команда к произведению распределения по устройствам. Первый параметр - ссылка на регион, которую вернул вызов region_create_(). Второй параметр – побитовое объединение типов устройств (DEVICE_TYPE_HOST = 1, DEVICE_TYPE_CUDA = 2).
void region_execute_on_targets_(DvmType *regionRef, DvmType *devicesRef);

// Обработка восстановления консистентности. Вызывать перед strtcg_, только внутри региона.
void region_handle_consistent_(DvmType *regionRef, DAConsistGroupRef *group);

// Обеспечение актуальных данных на устройствах региона в буферах удаленных элементов (и создание их).
void region_after_waitrb_(DvmType *regionRef, DvmType dvmDesc[]);

// Забывание буфера удаленных элементов, как страшный сон.
void region_destroy_rb_(DvmType *regionRef, DvmType dvmDesc[]);

// Конец региона. Параметр – ссылка на регион, которую вернул вызов region_create_().
void region_end_(DvmType *regionRef);


// Циклы
// Создает нечто для управления параллельным DVMH циклом. Первый параметр – ссылка на регион, которую вернул region_create_(). Второй параметр – DVM-описатель параллельного цикла.
DvmType loop_create_(DvmType *regionRef, LoopRef *InDvmLoop);

// Функция для включения редукции в параллельный DVMH цикл. Первый параметр – ссылка на нечто для управления параллельным DVMH циклом. Второй параметр – ссылка на DVMовскую редукционную функцию.
void loop_insred_(DvmType *InDvmhLoop, RedRef *InRedRefPtr);

// Функция для оповещения РТС-DVMH о теневых группах, созданных для обработки ACROSS. Т.к. вызов across_ исходные группы портит, то сюда следует передавать другие группы, равные тем.
void loop_across_(DvmType *InDvmhLoop, ShadowGroupRef *oldGroup, ShadowGroupRef *newGroup);

// Установка размера блока нитей. Первый параметр - ссылка на нечто для управления параллельным DVMH циклом. Второй параметр – размер блока нитей по оси X. Третий параметр - размер блока нитей по оси Y. Четвертый параметр - размер блока нитей по оси Z. Если размер по какой-то из осей не задан пользователем, то передавать в качестве соответствующего размера следует 1.
void loop_set_cuda_block_(DvmType *InDvmhLoop, DvmType *InXRef, DvmType *InYRef, DvmType *InZRef);

// Уведомление о том, какой массив изменяется при SHADOW_COMPUTE при данном параллельном цикле в регионе. Вызывать для всех изменяемых в цикле массивов. Если в цикле изменяются все выходные и локальные массивы региона (т.е. все те, которые зарегистрированы как out или local), то можно или сообщить о них всех, или вообще не сообщать - тогда примется консервативная позиция и будут считаться изменяемыми по SHADOW_COMPUTE все out и local массивы.
void loop_shadow_compute_(DvmType *InDvmhLoop, DvmType dvmDesc[]);

// Регистрация обработчика для параллельного цикла. Первый параметр - ссылка на нечто для управления параллельным DVMH циклом. Второй параметр - тип устройства, для которого годится данный обработчик (DEVICE_TYPE_HOST, ...). Третий параметр - набор флагов, указывающий характеристики обработчика (HANDLER_TYPE_PARALLEL = 1, HANDLER_TYPE_MASTER = 2). Четвертый параметр - ссылка на функцию-обработчик. Пятый параметр - количество передаваемых в обработчик базовых массивов. Шестой параметр - количество "пользовательских" параметров, которые необходимо передать обработчику. Седьмой и последующие - эти самые параметры (передача строго по адресу).
// HANDLER_TYPE_PARALLEL означает, что обработчик является параллельным и для него на усмотрение системы поддержки будет выделено несколько (1 или более) слотов исполнения для устройства. Такой обработчик должен сам запросить у системы поддержки свое количество слотов (функция loop_get_slot_count_()).
// HANDLER_TYPE_MASTER означает, что обработчик может исполняться только в главной нити хост-системы (в частности это влечет за собой тот факт, что других его инстанций в параллель запущено не будет). Этот флаг ставится в случае использования технологий, не готовых к внешнему параллелизму или плохо на него реагирующих. Пример - OpenMP, он слишком много нитей создаёт, если его запускать то из одной нити, то из другой. Этим флагом можно привязать.
void loop_register_handler_(DvmType *InDvmhLoop, DvmType *deviceTypeRef, DvmType *flagsRef, DvmHandlerFunc f, DvmType *basesCount, DvmType *paramCount,
        ...);

// Команда начала исполнения цикла. Параметр - ссылка на нечто для управления параллельным DVMH циклом. Если цикл синхронный, то в этом вызове будет происходить и ожидание конца цикла.
void loop_perform_(DvmType *InDvmhLoop);

// Эти функции вызываются из отдельных подпрограмм (обработчиков), а в основной программе нет баз кроме DVMовских и вообще нет следов CUDA.
// Получить номер устройства, на котором исполняется сейчас текущий обаботчик текущую порцию цикла.
DvmType loop_get_device_num_(DvmType *InDvmhLoop);

// Аналог tstelm_ для вызова в обработчиках. Возвращает 1, если элемент принадлежит локальной части массива на данном устройстве в данном регионе. Возвращает 0 иначе. Индексы глобальные и неперебазированные на нуль.
DvmType loop_has_element_(DvmType *InDvmhLoop, DvmType dvmDesc[], DvmType indexArray[]);

// Запрос на заполнение границ цикла (и шагов) для исполнения порции цикла обработчиком. Первый параметр - новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Любой из выходных массивов может быть NULL, тогда он не будет заполняться.
void loop_fill_bounds_(DvmType *InDvmhLoop, DvmType lowIndex[], DvmType highIndex[], DvmType stepIndex[]);

// Запрос на заполнение массива, описывающего локальную часть обрабатываемого сейчас обработчика. Для любых обработчиков на любых устройствах.
void loop_fill_local_part_(DvmType *InDvmhLoop, DvmType dvmDesc[], DvmType part[]);

// Запрос на заполнение редукционного массива и сопутствующего ему loc начальными данными. Первый параметр - новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – номер по порядку редукционной функции для цикла. Третий параметр – указатель на локальный для обработчика экземпляр редукционного массива. Четвертый параметр - указатель на локальный для обработчика экземпляр массива loc.
void loop_red_init_(DvmType *InDvmhLoop, DvmType *InRedNumRef, void *arrayPtr, void *locPtr);

// Запрос на получение количества слотов, выделенных для исполнения порции цикла в данном запуске данного обработчика.
DvmType loop_get_slot_count_(DvmType *InDvmhLoop);

// Запрос маски зависимых измерений параллельного цикла. Младший разряд соответствует внутреннему циклу. 1 - есть зависимость, 0 - нет зависимости.
DvmType loop_get_dependency_mask_(DvmType *InDvmhLoop);

// Запрос идентификатора целочисленного типа со знаком (из числа rt_XXX констант), достаточного для вычисления индексных выражений массивов в данном цикле при условии использования естественной (смещение равно нулю) или фактической (адрес начала фактического расположения элементов) базы.
DvmType loop_guess_index_type_(DvmType *InDvmhLoop);

// Функция для регистрации переменных, в которые будут помещены адреса редукционной переменной и ее LOC на устройстве. Первый параметр – новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – номер по порядку редукционной функции для цикла (нумерация с нуля). В ArrayPtr и LocPtr будут положены (в процессе итерирования цикла или вызовом loop_cuda_red_prepare_) адреса в памяти устройства, в которые ядро будет записывать информацию из блоков.
void loop_cuda_register_red(DvmType *InDvmhLoop, DvmType InRedNum, void **ArrayPtr, void **LocPtr);

// Альтернативная функция для запроса на заполнение редукционного массива и сопутствующего ему loc начальными данными, которая создаёт массивы начальных значений в памяти устройства. Первый параметр - новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – номер по порядку редукционной функции для цикла. Третий параметр - указатель на указатель, в который будет записан адрес в памяти устройства для массива начальных значений (допустим NULL - не создавать копию в памяти устройства). Четвертый параметр - указатель на указатель, в который будет записан адрес в памяти устройства для массива начальных значений для loc (допустим NULL - не создавать копию в памяти устройства).
void loop_cuda_red_init(DvmType *InDvmhLoop, DvmType InRedNum, void **devArrayPtr, void **devLocPtr);

// Выделение памяти на заданное количество редукционных переменных (возможно, с инициализацией) для последующего проведения редукции. Первый параметр – новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – номер по порядку редукционной функции для цикла (нумерация с нуля). Третий параметр – размер (в редукционных переменных) запрашиваемого массива (или двух в случаях MINLOC и MAXLOC). Четвертый параметр - флаг заполнения начальным значением (1 - заполнять, 0 - нет).
void loop_cuda_red_prepare(DvmType *InDvmhLoop, DvmType InRedNum, DvmType InCount, DvmType InFillFlag);

// Запрос на заполнение и выдачу массива, описывающего локальную часть обрабатываемого сейчас обработчика. Только для CUDA-обработчиков.
void *loop_cuda_get_local_part(DvmType *InDvmhLoop, DvmType dvmDesc[], DvmType indexType);

// Выполнить наилучшую для данного цикла трансформацию для данного массива для графической платы. Первый параметр - новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр - массив, для которого выполнить трансформацию.
// Возвращает тип произведенной трансформации: 0 - нет трансформации, 1 - перестановка измерений, 2 - подиагональная трансформация.
DvmType loop_cuda_autotransform(DvmType *InDvmhLoop, DvmType dvmDesc[]);

// Функция для запрашивания конфигурации для запуска ядер в данной порции цикла. Первый параметр – новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – необходимое количество байт разделяемой памяти в расчете на одну нить. Третий параметр – необходимое количество регистров в расчете на одну нить. Четвертый – входной и выходной параметр, который на входе имеет значение блока по-умолчанию (нулевой, если нет предпочтения), а на выходе заполняется выбранным блоком. Пятый и шестой параметры – выходные параметры для задания конфигурации запуска ядер.
void loop_cuda_get_config(DvmType *InDvmhLoop, DvmType InSharedPerThread, DvmType InRegsPerThread, void *InOutThreads, void *OutStream,
        DvmType *OutSharedPerBlock);

// Вызов для итерирования вызовов ядер на ГПУ. Возвращает 1, если надо запустить ядро после этого вызова и 0, если надо заканчивать. Первый параметр – новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – переменная типа dim3, в которую будут записаны размеры решетки блоков для запуска ядра. Третий параметр - тип индекса (rt_INT, rt_LONG, rt_LLONG). В InOutBlocks будет записан адрес на устройстве, где располагается информация для блоков.
DvmType loop_cuda_do(DvmType *InDvmhLoop, void *OutBlocks, void **InOutBlocksInfo, DvmType indexType);

// Возвращает расстояние (в штуках) между местами хранения соседних элементов редукционного массива в буфере в глобальной памяти ГПУ. Нужно для редукционных массивов. Если редукционных массивов нет, то возвращает нуль.
DvmType loop_cuda_get_red_step(DvmType *InDvmhLoop);

// Доделать редукцию, которую ранее зарегистрировали и для которой был запрошен буфер с помощью loop_cuda_red_prepare_. После данного вызова не делать loop_red_post_, так как он выполнится изнутри данного вызова.
void loop_red_finish(DvmType *InDvmhLoop, DvmType InRedNum);

// Возврат результатов частичной редукции в РТС. Первый параметр - новый локальный описатель параллельного DVMH цикла, который передается параметром в обработчик. Второй параметр – номер по порядку редукционной функции для цикла. Третий и четвертый - результаты работы обработчика порции цикла.
void loop_red_post_(DvmType *InDvmhLoop, DvmType *InRedNumRef, void *arrayPtr, void *locPtr);


// Утилиты
// Перетасовывает три массива boundsLow, boundsHigh и loopSteps так, чтобы сначала шли независимые измерения, а за ними зависимые (снаружи внутрь). depMask - маска зависимостей, как дана loop_get_dependency_mask_.
void dvmh_change_filled_bounds(DvmType *boundsLow, DvmType *boundsHigh, DvmType *loopSteps, DvmType rank, DvmType depCount, DvmType depMask,
        DvmType *idxPerm);


// Недокументированные возможности
DvmType dvmh_register_array_(DvmType dvmDesc[]);
DvmType dvmh_register_scalar_(void *addr, DvmType *sizeRef);
void loop_cuda_rtc_set_lang(DvmType *InDvmhLoop, DvmType lang);
void loop_cuda_rtc_launch(DvmType *InDvmhLoop, const char *kernelName, const char *src, void *blocks, DvmType numPar, ...);
DvmType loop_cuda_get_device_prop(DvmType *InDvmhLoop, DvmType prop);
DvmType dvmh_get_next_stage_(DvmType *dvmhRegRef, LoopRef *loopRef, DvmType *lineNumber, const char *fileName, int len);

}
#pragma GCC visibility pop
